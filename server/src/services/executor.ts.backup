import Ajv from 'ajv';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import {
  StoredEdge,
  StoredNode,
  ensureProjectDirs,
  getProject,
  hashContent,
  listProjectEdges,
  listProjectNodes,
  getNode,
  storeRun,
  updateNodeContent,
  updateNodeMetaSystem,
  withTransaction,
  createProjectNode,
  addProjectEdge,
} from '../db';
import { AiService } from './ai';
import { ParserService } from './parser';
import { TransformerService } from './transformerService';
import { autoDownloadMediaIfNeeded } from './mediaDownloader';
import { localFileToDataUri } from '../utils/storage';

// Контроль логгирования - установите в false для production
const DEBUG_LOGGING = process.env.NODE_ENV !== 'production';

const debugLog = (...args: any[]) => {
  if (DEBUG_LOGGING) {
    console.log(...args);
  }
};
import { executePython } from './pythonSandbox';
import { generatePreviz } from './videoGenStub';
// import { processMultiNodeResponse, ProcessedMultiNodes } from './multiNodeProcessor'; // Moved to experimental
import * as fs from 'fs';

// Динамически загружаем package.json
const getPackageInfo = () => {
  try {
    // Пробуем разные пути для разных окружений
    const possiblePaths = [
      path.resolve(__dirname, '../../package.json'), // dev mode
      path.resolve(process.cwd(), 'package.json'),   // portable mode
      path.resolve(__dirname, '../package.json'),    // другой случай
    ];
    
    for (const packagePath of possiblePaths) {
      if (fs.existsSync(packagePath)) {
        return JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      }
    }
    
    // Fallback если package.json не найден
    return { name: 'mindworkflow-server', version: '0.1.0' };
  } catch {
    return { name: 'mindworkflow-server', version: '0.1.0' };
  }
};

const serverPackage = getPackageInfo();

interface ExecutionContext {
  projectId: string;
  node: StoredNode;
  allNodes: Map<string, StoredNode>;
  edges: StoredEdge[];
  sortedNodeIds: string[];
}

type CreatedNodeSummary = {
  node_id: string;
  type: string;
  title: string;
};

type CreatedNodeSnapshot = CreatedNodeSummary & {
  content_type?: string | null;
  ui_position?: { x: number; y: number } | null;
  meta?: Record<string, unknown>;
};

export interface ExecutionResult {
  status: 'success' | 'failed';
  nodeId: string;
  content?: string | null;
  contentType?: string | null;
  logs: string[];
  runId: string;
  createdNodes?: CreatedNodeSummary[];
  createdNodeSnapshots?: CreatedNodeSnapshot[];
  isMultiNodeResult?: boolean;
  predictionUrl?: string;
  predictionId?: string;
  provider?: string;
  predictionPayload?: unknown;
}

interface RetryOutcome<T> {
  result: T;
  attempts: number;
  logs: string[];
}

interface ExecutionStepResult {
  content: string;
  contentType: string;
  logs: string[];
  createdNodes?: CreatedNodeSummary[];
  createdNodeSnapshots?: CreatedNodeSnapshot[];
  isMultiNodeResult?: boolean;
  predictionUrl?: string;
  predictionId?: string;
  provider?: string;
  predictionPayload?: unknown;
}

const MAX_ATTEMPTS = 3;
const BACKOFF = [0, 1_000, 2_000];

export class ExecutorService {
  private readonly aiService: AiService;
  private readonly parserService: ParserService;
  private readonly transformerService: TransformerService;
  private readonly engineVersion: string;
  
  // Guard против двойного вызова createReplicateAssetNodes
  private static processingPredictions = new Set<string>();
  private static processingPromises = new Map<string, Promise<any>>();

  constructor(private readonly ajv: Ajv) {
    this.aiService = new AiService(ajv);
    this.parserService = new ParserService(ajv);
    this.transformerService = new TransformerService();
    this.engineVersion = serverPackage.version ?? '0.0.0';
  }

  // EXPERIMENTAL FEATURE - Multi-node creation disabled
  /*
  private async createMultipleNodes(
    projectId: string, 
    sourceNodeId: string, 
    multiNodeResult: ProcessedMultiNodes
  ): Promise<Array<{ node_id: string; type: string; title: string }>> {
    const createdNodes: Array<{ node_id: string; type: string; title: string }> = [];
    
    return withTransaction(() => {
      for (const nodeSpec of multiNodeResult.nodes) {
        const { node } = createProjectNode(projectId, {
          type: nodeSpec.type,
          title: nodeSpec.title,
          content: nodeSpec.content || '',
          slug: nodeSpec.slug,
          meta: nodeSpec.meta,
          ai: nodeSpec.ai,
        }, {
          position: { x: nodeSpec.x, y: nodeSpec.y }
        });
        
        // Add edge from source AI node to created node
        addProjectEdge(projectId, {
          from: sourceNodeId,
          to: node.node_id,
        });
        
        createdNodes.push({
          node_id: node.node_id,
          type: node.type,
          title: node.title,
        });
      }
      
      return createdNodes;
    });
  }
  */

  // Собираем файлы из предыдущих нод (файлы, изображения, документы)
  private async collectFilesFromPreviousNodes(previousNodes: StoredNode[]): Promise<Array<{
    name: string;
    type: string;
    content: string;
    source_node_id: string;
  }>> {
    const files: Array<{
      name: string;
      type: string;
      content: string;
      source_node_id: string;
    }> = [];

    for (const node of previousNodes) {
      // Обрабатываем файловые ноды
      if (node.type === 'file' && node.content) {
        files.push({
          name: node.title || 'file.txt',
          type: node.content_type || 'text/plain',
          content: node.content,
          source_node_id: node.node_id,
        });
      }

      // Обрабатываем изображения
      if (node.type === 'image') {
        const meta = node.meta as any;
        if (meta?.image_url) {
          // ✅ Конвертируем localhost URLs в data URIs для внешних API
          const imageUrl = await this.convertUrlToDataUriIfNeeded(meta.image_url);
          const fileType = imageUrl.startsWith('data:') ? 'image/base64' : 'image/url';
          
          files.push({
            name: node.title || 'image.jpg',
            type: fileType,
            content: imageUrl,
            source_node_id: node.node_id,
          });
        }
        if (meta?.image_data) {
          files.push({
            name: node.title || 'image.base64',
            type: 'image/base64',
            content: meta.image_data,
            source_node_id: node.node_id,
          });
        }
      }

      // Обрабатываем текстовые ноды как документы
      if (node.type === 'text' && node.content && node.content.length > 100) {
        files.push({
          name: node.title || 'document.txt',
          type: 'text/plain',
          content: node.content,
          source_node_id: node.node_id,
        });
      }

      // Обрабатываем HTML ноды
      if (node.type === 'html' && node.content) {
        files.push({
          name: node.title || 'document.html',
          type: 'text/html',
          content: node.content,
          source_node_id: node.node_id,
        });
      }

      // Обрабатываем markdown ноды
      if (node.type === 'markdown' && node.content) {
        files.push({
          name: node.title || 'document.md',
          type: 'text/markdown',
          content: node.content,
          source_node_id: node.node_id,
        });
      }
    }

    return files;
  }

  async runNode(
    projectId: string,
    nodeId: string,
    options?: { actorUserId?: string | null },
  ): Promise<ExecutionResult> {
    ensureProjectDirs(projectId);

    const { node, allNodes, edges, sortedNodeIds } = this.buildExecutionContext(projectId, nodeId);

    const baseAiConfig = (node.config.ai ?? {}) as Record<string, unknown>;
    const shouldLimitContext = node.type === 'ai' || node.type === 'ai_improved';
    const contextLeftDepth = shouldLimitContext
      ? this.normalizeContextDepthValue(baseAiConfig.context_left_depth, 1)
      : Number.POSITIVE_INFINITY;
    const contextRightDepth = shouldLimitContext
      ? this.normalizeContextDepthValue(baseAiConfig.context_right_depth, 0)
      : Number.POSITIVE_INFINITY;

    const previousNodes = this.collectPreviousNodes(nodeId, sortedNodeIds, allNodes, edges, {
      maxDepth: contextLeftDepth,
    });
    const nextMetadata = this.collectNextNodeMetadata(nodeId, allNodes, edges, {
      maxDepth: contextRightDepth,
    });
    const project = getProject(projectId, undefined, { bypassAuth: true });
    if (!project) {
      throw new Error(`Project ${projectId} not found`);
    }
    const actorUserId = options?.actorUserId ?? null;
    const projectOwnerId =
      typeof project.user_id === 'string' && project.user_id.trim().length > 0
        ? project.user_id
        : null;

    const inputFingerprint = {
      node: {
        node_id: node.node_id,
        type: node.type,
        config: node.config,
      },
      previous: previousNodes.map((item) => ({
        node_id: item.node_id,
        type: item.type,
        content_hash: hashContent(item.content ?? null),
      })),
      next: nextMetadata,
      engineVersion: this.engineVersion,
    };

    const startedAt = new Date().toISOString();
    const runId = uuidv4();

    console.log('[DEBUG] >>>>> EXECUTE NODE:', node.node_id, 'type:', node.type, 'meta:', JSON.stringify(node.meta));

    try {
      const outcome = await this.withRetry<ExecutionStepResult>(async () => {
        console.log('[DEBUG] >>>>> INSIDE withRetry for node:', node.node_id);
        switch (node.type) {
        case 'ai': {
          console.log('[DEBUG] Processing AI node:', node.node_id, 'output_type:', node.meta?.output_type);
          const aiConfig = baseAiConfig;
          const outputType = node.meta?.output_type as string;
          const providerId =
            typeof aiConfig.provider === 'string' ? aiConfig.provider : '';
          const filesForProvider =
            providerId === 'midjourney_proxy' || providerId === 'google_ai_studio'
              ? await this.collectFilesFromPreviousNodes(previousNodes)
              : undefined;
          debugLog(`[Executor DEBUG] Node config:`, JSON.stringify(aiConfig, null, 2));
          debugLog(`[Executor DEBUG] Node meta output_type:`, outputType);
          
          // Проверяем тип вывода из мета-данных
          if (outputType === 'mindmap' || aiConfig.response_type === 'mindmap') {
            // Для mindmap используем MINDMAP_SCHEMA для правильного JSON формата
            const schemaRef = 'MINDMAP_SCHEMA';
            debugLog(`[Executor] Node ${node.node_id}: Using ${schemaRef} for mindmap output`);
            
            const contextMode = (aiConfig.context_mode || 'simple') as 'simple' | 'full_json';
            
            const aiResult = await this.aiService.run({
              projectId,
              node,
              previousNodes,
              nextNodes: nextMetadata,
              schemaRef,
              settings: (project.settings ?? {}) as Record<string, unknown>,
              projectOwnerId,
              actorUserId,
              files: filesForProvider,
              contextMode,
            });
            
            // Используем transformer service для создания дерева нод
            try {
              let jsonContent = aiResult.output;
              
              // Если ответ обернут в {"response": "..."}, извлекаем внутренний JSON
              try {
                const parsed = JSON.parse(jsonContent);
                if (parsed.response && typeof parsed.response === 'string') {
                  jsonContent = parsed.response;
                  debugLog(`[Executor] Extracted inner JSON from response wrapper`);
                }
              } catch (parseError) {
                // Если не JSON, продолжаем с оригиналом
                debugLog(`[Executor] Could not parse response wrapper, using original content`);
              }
              
              debugLog(`[Executor] Transforming MINDMAP JSON to nodes:`, jsonContent.substring(0, 200));
              
              const transformerResult = await this.transformerService.transformJsonToNodes(
                projectId,
                node.node_id,
                jsonContent,
                node.ui.bbox.x2 + 100,
                node.ui.bbox.y1
              );
              
              return {
                content: `Создан mindmap из ${transformerResult.createdNodes.length} нод: ${transformerResult.createdNodes.map(n => n.title).join(', ')}`,
                contentType: 'text/plain',
                logs: [...aiResult.logs, ...transformerResult.logs],
                createdNodes: transformerResult.createdNodes,
                isMultiNodeResult: true,
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? providerId,
              };
            } catch (error) {
              console.error('[Executor] Error creating mindmap:', error);
              return {
                content: `Ошибка создания mindmap: ${error instanceof Error ? error.message : 'Unknown error'}\n\nОтвет ИИ:\n${aiResult.output}`,
                contentType: 'text/plain',
                logs: [...aiResult.logs, `Error: ${error instanceof Error ? error.message : 'Unknown error'}`],
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? providerId,
              };
            }
          } else if (outputType === 'node') {
            // Для режима 'node' создаем отдельную ноду с ответом
            console.log('[DEBUG] ENTERED outputType=node branch for node:', node.node_id);
            debugLog(`[Executor] Node ${node.node_id}: Creating single output node`);
            
            const contextMode = (aiConfig.context_mode || 'simple') as 'simple' | 'full_json';
            
            const aiResult = await this.aiService.run({
              projectId,
              node,
              previousNodes,
              nextNodes: nextMetadata,
              schemaRef: 'TEXT_RESPONSE', // Используем обычную схему для текстового ответа
              settings: (project.settings ?? {}) as Record<string, unknown>,
              projectOwnerId,
              actorUserId,
              files: filesForProvider,
              contextMode,
            });
            
            let singleParsedOutput: unknown = null;
            if (typeof aiResult.output === 'string') {
              try {
                singleParsedOutput = JSON.parse(aiResult.output);
              } catch (error) {
                console.log(
                  '[DEBUG] Failed to parse single-node output as JSON:',
                  error instanceof Error ? error.message : String(error),
                );
              }
            }

            let nodeArtifacts: {
              createdNodes: CreatedNodeSummary[];
              nodeSnapshots: CreatedNodeSnapshot[];
              logs: string[];
            } = { createdNodes: [], nodeSnapshots: [], logs: [] };

            console.log('[DEBUG] Before Replicate check - aiResult.provider:', aiResult.provider);
            console.log('[DEBUG] Before Replicate check - singleParsedOutput type:', typeof singleParsedOutput, 'value:', singleParsedOutput);

            if (
              aiResult.provider === 'replicate' ||
              (singleParsedOutput && typeof singleParsedOutput === 'object' && singleParsedOutput !== null)
            ) {
              console.log('[DEBUG] ===== ENTERING Replicate asset creation branch =====');
              console.log('[DEBUG] aiResult full:', JSON.stringify(aiResult, null, 2));
              const outputCandidates = this.collectReplicateOutputCandidates(aiResult, singleParsedOutput);
              console.log('[DEBUG] outputCandidates after collect:', outputCandidates);
              nodeArtifacts = await this.createReplicateAssetNodes(
                projectId,
                node,
                outputCandidates,
                aiResult.predictionId,
                aiResult.predictionUrl,
              );
              if (nodeArtifacts.createdNodes.length === 0) {
                const primaryFallback = this.extractPrimaryReplicateOutput(outputCandidates);
                if (primaryFallback) {
                  const fallbackArtifacts = await this.createReplicateAssetNodes(
                    projectId,
                    node,
                    [primaryFallback],
                    aiResult.predictionId,
                    aiResult.predictionUrl,
                  );
                  if (fallbackArtifacts.createdNodes.length > 0) {
                    nodeArtifacts = fallbackArtifacts;
                  }
                }
              }
            }

            if (nodeArtifacts.nodeSnapshots.length > 0) {
              this.applyCreatedNodesToMeta(projectId, node, nodeArtifacts.nodeSnapshots, {
                predictionPayload: aiResult.predictionPayload,
              });

              const byType = new Map<string, number>();
              nodeArtifacts.createdNodes.forEach((createdNode) => {
                byType.set(createdNode.type, (byType.get(createdNode.type) ?? 0) + 1);
              });
              const totalLabel = this.selectRussianPlural(nodeArtifacts.createdNodes.length, [
                'артефакт',
                'артефакта',
                'артефактов',
              ]);
              const summaryFragments = Array.from(byType.entries()).map(
                ([type, count]) => `${count} ${this.describeArtifactPlural(type, count)}`,
              );
              return {
                content: `Создано ${nodeArtifacts.createdNodes.length} ${totalLabel}: ${summaryFragments.join(', ')}.`,
                contentType: 'text/plain',
                logs: [...aiResult.logs, ...nodeArtifacts.logs],
                createdNodes: nodeArtifacts.createdNodes,
                createdNodeSnapshots: nodeArtifacts.nodeSnapshots,
                isMultiNodeResult: nodeArtifacts.createdNodes.length > 0,
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? providerId,
                predictionPayload: aiResult.predictionPayload,
              };
            }

            if (aiResult.provider === 'replicate' && aiResult.predictionPayload !== undefined) {
              this.applyCreatedNodesToMeta(projectId, node, [], {
                predictionPayload: aiResult.predictionPayload,
              });
            }

            if (aiResult.provider === 'replicate') {
              return {
                content: aiResult.output,
                contentType: aiResult.contentType,
                logs: aiResult.logs,
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? providerId,
                predictionPayload: aiResult.predictionPayload,
              };
            }

            try {
              const createdNode = await this.transformerService.createSingleTextNode(
                projectId,
                node.node_id,
                aiResult.output,
                'Ответ AI агента',
                node.ui.bbox.x2 + 100,
                node.ui.bbox.y1,
              );

              return {
                content: `Создана нода с ответом: "${createdNode.title}"`,
                contentType: 'text/plain',
                logs: aiResult.logs,
                createdNodes: [createdNode],
                isMultiNodeResult: true,
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? providerId,
                predictionPayload: aiResult.predictionPayload,
              };
            } catch (error) {
              console.error('[Executor] Error creating output node:', error);
              return {
                content: `Ошибка создания ноды: ${error instanceof Error ? error.message : 'Unknown error'}\n\nОтвет ИИ:\n${aiResult.output}`,
                contentType: 'text/plain',
                logs: [...aiResult.logs, `Error: ${error instanceof Error ? error.message : 'Unknown error'}`],
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? providerId,
                predictionPayload: aiResult.predictionPayload,
              };
            }
          } else {
            // Для обычного режима используем TEXT_RESPONSE для простого ответа
            const schemaRef = 'TEXT_RESPONSE';
            debugLog(`[Executor] Node ${node.node_id}: Using ${schemaRef} for single node output`);
            
            const contextMode = (aiConfig.context_mode || 'simple') as 'simple' | 'full_json';
            
          const aiResult = await this.aiService.run({
            projectId,
            node,
            previousNodes,
            nextNodes: nextMetadata,
            schemaRef,
            settings: (project.settings ?? {}) as Record<string, unknown>,
            projectOwnerId,
            actorUserId,
            files: filesForProvider,
            contextMode,
          });

            // Parse output if it's JSON
            let parsedOutput = null;
            if (typeof aiResult.output === 'string') {
              try {
                parsedOutput = JSON.parse(aiResult.output);
                console.log('[DEBUG] Parsed output as JSON');
              } catch (e) {
                console.log('[DEBUG] Failed to parse output as JSON:', e instanceof Error ? e.message : String(e));
              }
            }

            let replicateArtifacts: {
              createdNodes: CreatedNodeSummary[];
              nodeSnapshots: CreatedNodeSnapshot[];
              logs: string[];
            } = { createdNodes: [], nodeSnapshots: [], logs: [] };

            if (aiResult.provider === 'replicate' || parsedOutput) {
              console.log('[DEBUG] Calling createReplicateAssetNodes');
              const outputCandidates = this.collectReplicateOutputCandidates(aiResult, parsedOutput);
              replicateArtifacts = await this.createReplicateAssetNodes(
                projectId,
                node,
                outputCandidates,
                aiResult.predictionId,
                aiResult.predictionUrl,
              );
              if (replicateArtifacts.createdNodes.length === 0) {
                const primaryFallback = this.extractPrimaryReplicateOutput(outputCandidates);
                if (primaryFallback) {
                  const fallbackArtifacts = await this.createReplicateAssetNodes(
                    projectId,
                    node,
                    [primaryFallback],
                    aiResult.predictionId,
                    aiResult.predictionUrl,
                  );
                  if (fallbackArtifacts.createdNodes.length > 0) {
                    replicateArtifacts = fallbackArtifacts;
                  }
                }
              }
            }

            if (replicateArtifacts.nodeSnapshots.length > 0) {
              this.applyCreatedNodesToMeta(projectId, node, replicateArtifacts.nodeSnapshots, {
                predictionPayload: aiResult.predictionPayload,
              });
            } else if (aiResult.predictionPayload !== undefined && aiResult.provider === 'replicate') {
              this.applyCreatedNodesToMeta(projectId, node, [], {
                predictionPayload: aiResult.predictionPayload,
              });
            }

            const combinedLogs = [...aiResult.logs, ...replicateArtifacts.logs];

            // For Replicate, extract the actual output URL if it's wrapped in a response object
            let finalContent = aiResult.output;
            console.log('[DEBUG] aiResult.provider:', aiResult.provider, 'output type:', typeof aiResult.output);
            if (parsedOutput && typeof parsedOutput === 'object' && !Array.isArray(parsedOutput) && (parsedOutput as any).output) {
              finalContent = (parsedOutput as any).output;
              console.log('[DEBUG] Extracted output URL for content:', finalContent);
            }

            // If we created asset nodes for Replicate, use a summary as content instead of the raw output
            if (aiResult.provider === 'replicate' && replicateArtifacts.createdNodes.length > 0) {
              const byType = new Map<string, number>();
              replicateArtifacts.createdNodes.forEach((node) => {
                byType.set(node.type, (byType.get(node.type) ?? 0) + 1);
              });
              const totalLabel = this.selectRussianPlural(replicateArtifacts.createdNodes.length, [
                'артефакт',
                'артефакта',
                'артефактов',
              ]);
              const fragments = Array.from(byType.entries()).map(
                ([type, count]) => `${count} ${this.describeArtifactPlural(type, count)}`,
              );
              finalContent = `Создано ${replicateArtifacts.createdNodes.length} ${totalLabel}: ${fragments.join(', ')}.`;
            }

            if (aiResult.provider === 'replicate') {
              return {
                content: finalContent,
                contentType: aiResult.contentType,
                logs: combinedLogs,
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? providerId,
                predictionPayload: aiResult.predictionPayload,
              };
            }

            return {
              content: finalContent,
              contentType: aiResult.contentType,
              logs: combinedLogs,
              createdNodes: replicateArtifacts.createdNodes,
              createdNodeSnapshots: replicateArtifacts.nodeSnapshots,
              isMultiNodeResult: replicateArtifacts.createdNodes.length > 0,
              predictionUrl: aiResult.predictionUrl,
              predictionId: aiResult.predictionId,
              provider: aiResult.provider ?? providerId,
              predictionPayload: aiResult.predictionPayload,
            };
          }
        }
        case 'ai_improved': {
          // Handle ai_improved nodes with support for different response types
          const aiConfig = { ...baseAiConfig } as Record<string, unknown>;
          const responseType = aiConfig.response_type as string;
          const outputType = node.meta?.output_type as string;
          
          // Собираем файлы из предыдущих нод
          const files = await this.collectFilesFromPreviousNodes(previousNodes);
          debugLog(`[Executor] AI Improved node ${node.node_id}: response_type = ${responseType}, output_type = ${outputType}, files: ${files.length}`);

          // Для mindmap используем planner_prompt как system_prompt
          if (responseType === 'mindmap' && aiConfig.planner_prompt) {
            aiConfig.system_prompt = aiConfig.planner_prompt;
            debugLog(`[Executor] Using planner_prompt for mindmap generation`);
          }

          // Проверяем output_type из метаданных (приоритет над response_type)
          if (outputType === 'mindmap' || responseType === 'tree' || responseType === 'mindmap') {
            const schemaRef = (outputType === 'mindmap' || responseType === 'mindmap') ? 'MINDMAP_SCHEMA' : 'TEXT_RESPONSE';
            
            const contextMode = (aiConfig.context_mode || 'simple') as 'simple' | 'full_json';
            
            const aiResult = await this.aiService.run({
              projectId,
              node: { ...node, config: { ...node.config, ai: aiConfig } },
              previousNodes,
              nextNodes: nextMetadata,
              schemaRef,
              settings: (project.settings ?? {}) as Record<string, unknown>,
              projectOwnerId,
              actorUserId,
              files,
              contextMode,
            });
            
            // Use transformer service to create node tree
            try {
              let jsonContent = aiResult.output;
              
              // Если ответ обернут в {"response": "..."}, извлекаем внутренний JSON
              if (schemaRef === 'MINDMAP_SCHEMA') {
                try {
                  const parsed = JSON.parse(jsonContent);
                  if (parsed.response && typeof parsed.response === 'string') {
                    jsonContent = parsed.response;
                    debugLog(`[Executor] Extracted inner JSON from response wrapper`);
                  }
                } catch (parseError) {
                  // Если не JSON, продолжаем с оригиналом
                  debugLog(`[Executor] Could not parse response wrapper, using original content`);
                }
              }
              
              // Если не используем MINDMAP_SCHEMA, пробуем извлечь JSON из текста
              if (schemaRef !== 'MINDMAP_SCHEMA') {
                // Try to extract JSON from markdown code blocks
                const jsonMatch = jsonContent.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
                if (jsonMatch) {
                  jsonContent = jsonMatch[1].trim();
                }
                
                // Try to find JSON object in the text
                const jsonObjectMatch = jsonContent.match(/\{[\s\S]*\}/);
                if (jsonObjectMatch && !jsonMatch) {
                  jsonContent = jsonObjectMatch[0];
                }
              }
              
              debugLog(`[Executor] Creating mindmap from AI_IMPROVED output (${schemaRef}):`, jsonContent.substring(0, 200));
              
              const transformerResult = await this.transformerService.transformJsonToNodes(
                projectId,
                node.node_id,
                jsonContent,
                node.ui.bbox.x2 + 100,
                node.ui.bbox.y1
              );
              
              const modeText = outputType === 'mindmap' ? 'mindmap' : 'дерево';
              return {
                content: `Создан ${modeText} из ${transformerResult.createdNodes.length} нод: ${transformerResult.createdNodes.map(n => n.title).join(', ')}`,
                contentType: 'text/plain',
                logs: [...aiResult.logs, ...transformerResult.logs],
                createdNodes: transformerResult.createdNodes,
                isMultiNodeResult: true,
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? (typeof aiConfig.provider === 'string' ? aiConfig.provider : undefined),
              };
            } catch (error) {
              console.error('[Executor] Error creating node tree:', error);
              return {
                content: `Ошибка создания дерева нод: ${error instanceof Error ? error.message : 'Unknown error'}\n\nОтвет ИИ:\n${aiResult.output}`,
                contentType: 'text/plain',
                logs: [...aiResult.logs, `Error: ${error instanceof Error ? error.message : 'Unknown error'}`],
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? (typeof aiConfig.provider === 'string' ? aiConfig.provider : undefined),
              };
            }
          } else if (outputType === 'node') {
            // Для режима 'node' создаем отдельную ноду с ответом
            debugLog(`[Executor] AI Improved node ${node.node_id}: Creating single output node`);
            
            const contextMode = (aiConfig.context_mode || 'simple') as 'simple' | 'full_json';
            
            const aiResult = await this.aiService.run({
              projectId,
              node,
              previousNodes,
              nextNodes: nextMetadata,
              schemaRef: 'TEXT_RESPONSE', // Используем обычную схему для текстового ответа
              settings: (project.settings ?? {}) as Record<string, unknown>,
              projectOwnerId,
              actorUserId,
              files,
              contextMode,
            });

            // Parse output if it's a JSON string
            let singleParsedOutput: unknown = null;
            if (typeof aiResult.output === 'string') {
              try {
                singleParsedOutput = JSON.parse(aiResult.output);
              } catch (error) {
                console.log(
                  '[DEBUG] Failed to parse ai_improved output as JSON:',
                  error instanceof Error ? error.message : String(error),
                );
              }
            }

            let nodeArtifacts: {
              createdNodes: CreatedNodeSummary[];
              nodeSnapshots: CreatedNodeSnapshot[];
              logs: string[];
            } = { createdNodes: [], nodeSnapshots: [], logs: [] };

            console.log('[DEBUG] AI_IMPROVED Before Replicate check - aiResult.provider:', aiResult.provider);
            console.log('[DEBUG] AI_IMPROVED Before Replicate check - singleParsedOutput type:', typeof singleParsedOutput, 'value:', singleParsedOutput);

            // Check if this is a Replicate response with artifacts
            if (
              aiResult.provider === 'replicate' ||
              (singleParsedOutput && typeof singleParsedOutput === 'object' && singleParsedOutput !== null)
            ) {
              console.log('[DEBUG] AI_IMPROVED ===== ENTERING Replicate asset creation branch =====');
              console.log('[DEBUG] AI_IMPROVED aiResult full:', JSON.stringify(aiResult, null, 2));
              const outputCandidates = this.collectReplicateOutputCandidates(aiResult, singleParsedOutput);
              console.log('[DEBUG] AI_IMPROVED outputCandidates after collect:', outputCandidates);
              nodeArtifacts = await this.createReplicateAssetNodes(
                projectId,
                node,
                outputCandidates,
                aiResult.predictionId,
                aiResult.predictionUrl,
              );
              if (nodeArtifacts.createdNodes.length === 0) {
                const primaryFallback = this.extractPrimaryReplicateOutput(outputCandidates);
                if (primaryFallback) {
                  const fallbackArtifacts = await this.createReplicateAssetNodes(
                    projectId,
                    node,
                    [primaryFallback],
                    aiResult.predictionId,
                    aiResult.predictionUrl,
                  );
                  if (fallbackArtifacts.createdNodes.length > 0) {
                    nodeArtifacts = fallbackArtifacts;
                  }
                }
              }
            }

            // If we created Replicate artifacts, return them
            if (nodeArtifacts.nodeSnapshots.length > 0) {
              this.applyCreatedNodesToMeta(projectId, node, nodeArtifacts.nodeSnapshots, {
                predictionPayload: aiResult.predictionPayload,
              });

              const byType = new Map<string, number>();
              nodeArtifacts.createdNodes.forEach((createdNode) => {
                byType.set(createdNode.type, (byType.get(createdNode.type) ?? 0) + 1);
              });
              const totalLabel = this.selectRussianPlural(nodeArtifacts.createdNodes.length, [
                'артефакт',
                'артефакта',
                'артефактов',
              ]);
              const summaryFragments = Array.from(byType.entries()).map(
                ([type, count]) => `${count} ${this.describeArtifactPlural(type, count)}`,
              );
              return {
                content: `Создано ${nodeArtifacts.createdNodes.length} ${totalLabel}: ${summaryFragments.join(', ')}.`,
                contentType: 'text/plain',
                logs: [...aiResult.logs, ...nodeArtifacts.logs],
                createdNodes: nodeArtifacts.createdNodes,
                createdNodeSnapshots: nodeArtifacts.nodeSnapshots,
                isMultiNodeResult: nodeArtifacts.createdNodes.length > 0,
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? (typeof aiConfig.provider === 'string' ? aiConfig.provider : undefined),
                predictionPayload: aiResult.predictionPayload,
              };
            }

            // If Replicate provider but no artifacts, save prediction payload
            if (aiResult.provider === 'replicate' && aiResult.predictionPayload !== undefined) {
              this.applyCreatedNodesToMeta(projectId, node, [], {
                predictionPayload: aiResult.predictionPayload,
              });
            }

            // If Replicate provider, return output without creating text node
            if (aiResult.provider === 'replicate') {
              return {
                content: aiResult.output,
                contentType: aiResult.contentType,
                logs: aiResult.logs,
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? (typeof aiConfig.provider === 'string' ? aiConfig.provider : undefined),
                predictionPayload: aiResult.predictionPayload,
              };
            }

            // Fallback: Create text node for non-Replicate providers
            try {
              const createdNode = await this.transformerService.createSingleTextNode(
                projectId,
                node.node_id,
                aiResult.output,
                'Ответ AI агента',
                node.ui.bbox.x2 + 100,
                node.ui.bbox.y1
              );
              return {
                content: `Создана нода с ответом: "${createdNode.title}"`,
                contentType: 'text/plain',
                logs: aiResult.logs,
                createdNodes: [createdNode],
                isMultiNodeResult: true,
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? (typeof aiConfig.provider === 'string' ? aiConfig.provider : undefined),
              };
            } catch (error) {
              console.error('[Executor] Error creating output node:', error);
              return {
                content: `Ошибка создания ноды: ${error instanceof Error ? error.message : 'Unknown error'}\n\nОтвет ИИ:\n${aiResult.output}`,
                contentType: 'text/plain',
                logs: [...aiResult.logs, `Error: ${error instanceof Error ? error.message : 'Unknown error'}`],
                predictionUrl: aiResult.predictionUrl,
                predictionId: aiResult.predictionId,
                provider: aiResult.provider ?? (typeof aiConfig.provider === 'string' ? aiConfig.provider : undefined),
              };
            }
          } else if (responseType === 'folder') {
            // Determine schema based on response type
            const schemaRef = 'TEXT_RESPONSE'; // Use text response for file descriptions (for now)
            
            const contextMode = (aiConfig.context_mode || 'simple') as 'simple' | 'full_json';
            
            const aiResult = await this.aiService.run({
              projectId,
              node,
              previousNodes,
              nextNodes: nextMetadata,
              schemaRef,
              settings: (project.settings ?? {}) as Record<string, unknown>,
              projectOwnerId,
              actorUserId,
              contextMode,
            });
            
            // TODO: Implement folder creation logic
            // This would parse AI response for file specifications and create actual files
            return {
              content: `Режим "папка файлов" в разработке. Ответ ИИ:\n${aiResult.output}`,
              contentType: 'text/plain',
              logs: [...aiResult.logs, 'Folder mode not yet implemented'],
              predictionUrl: aiResult.predictionUrl,
              predictionId: aiResult.predictionId,
              provider: aiResult.provider ?? (typeof aiConfig.provider === 'string' ? aiConfig.provider : undefined),
            };
          } else {
            // Default single response
            const schemaRef = 'TEXT_RESPONSE'; // Default for single response
            
            const contextMode = (aiConfig.context_mode || 'simple') as 'simple' | 'full_json';
            
            const aiResult = await this.aiService.run({
              projectId,
              node,
              previousNodes,
              nextNodes: nextMetadata,
              schemaRef,
              settings: (project.settings ?? {}) as Record<string, unknown>,
              projectOwnerId,
              actorUserId,
              files,
              contextMode,
            });

            let parsedOutput: unknown = null;
            if (typeof aiResult.output === 'string') {
              try {
                parsedOutput = JSON.parse(aiResult.output);
                console.log('[DEBUG] Parsed AI_IMPROVED output as JSON');
              } catch (error) {
                console.log(
                  '[DEBUG] Failed to parse AI_IMPROVED output as JSON:',
                  error instanceof Error ? error.message : String(error),
                );
              }
            }

            let replicateArtifacts: {
              createdNodes: CreatedNodeSummary[];
              nodeSnapshots: CreatedNodeSnapshot[];
              logs: string[];
            } = { createdNodes: [], nodeSnapshots: [], logs: [] };

            if (
              aiResult.provider === 'replicate' ||
              (parsedOutput && typeof parsedOutput === 'object' && parsedOutput !== null)
            ) {
              console.log('[DEBUG] AI_IMPROVED: triggering createReplicateAssetNodes');
              const outputCandidates = this.collectReplicateOutputCandidates(aiResult, parsedOutput);
              replicateArtifacts = await this.createReplicateAssetNodes(
                projectId,
                node,
                outputCandidates,
                aiResult.predictionId,
                aiResult.predictionUrl,
              );
              if (replicateArtifacts.createdNodes.length === 0) {
                const primaryFallback = this.extractPrimaryReplicateOutput(outputCandidates);
                if (primaryFallback) {
                  const fallbackArtifacts = await this.createReplicateAssetNodes(
                    projectId,
                    node,
                    [primaryFallback],
                    aiResult.predictionId,
                    aiResult.predictionUrl,
                  );
                  if (fallbackArtifacts.createdNodes.length > 0) {
                    replicateArtifacts = fallbackArtifacts;
                  }
                }
              }
            }

            if (replicateArtifacts.nodeSnapshots.length > 0) {
              this.applyCreatedNodesToMeta(projectId, node, replicateArtifacts.nodeSnapshots, {
                predictionPayload: aiResult.predictionPayload,
              });
            } else if (aiResult.predictionPayload !== undefined && aiResult.provider === 'replicate') {
              this.applyCreatedNodesToMeta(projectId, node, [], {
                predictionPayload: aiResult.predictionPayload,
              });
            }

            const combinedLogs = [...aiResult.logs, ...replicateArtifacts.logs];
            let finalContent = aiResult.output;

            if (
              parsedOutput &&
              typeof parsedOutput === 'object' &&
              !Array.isArray(parsedOutput) &&
              (parsedOutput as Record<string, unknown>).output
            ) {
              finalContent = String((parsedOutput as Record<string, unknown>).output);
            }

            if (replicateArtifacts.createdNodes.length > 0) {
              const byType = new Map<string, number>();
              replicateArtifacts.createdNodes.forEach((createdNode) => {
                byType.set(createdNode.type, (byType.get(createdNode.type) ?? 0) + 1);
              });
              const totalLabel = this.selectRussianPlural(replicateArtifacts.createdNodes.length, [
                'артефакт',
                'артефакта',
                'артефактов',
              ]);
              const fragments = Array.from(byType.entries()).map(
                ([type, count]) => `${count} ${this.describeArtifactPlural(type, count)}`,
              );
              finalContent = `Создано ${replicateArtifacts.createdNodes.length} ${totalLabel}: ${fragments.join(', ')}.`;
            }

            return {
              content: finalContent,
              contentType: aiResult.contentType,
              logs: combinedLogs,
              createdNodes: replicateArtifacts.createdNodes,
              createdNodeSnapshots: replicateArtifacts.nodeSnapshots,
              isMultiNodeResult: replicateArtifacts.createdNodes.length > 0,
              predictionUrl: aiResult.predictionUrl,
              predictionId: aiResult.predictionId,
              provider: aiResult.provider ?? (typeof aiConfig.provider === 'string' ? aiConfig.provider : undefined),
              predictionPayload: aiResult.predictionPayload,
            };
          }
        }
        case 'parser': {
          const htmlSource = previousNodes[previousNodes.length - 1]?.content ?? '';
          const parserConfig = (node.config.parser ?? {}) as Record<string, unknown>;
          const schemaRef = String(parserConfig.output_schema_ref ?? 'PARSE_SCHEMA');
          const parserResult = this.parserService.run({
            html: htmlSource,
            source: node.node_id,
            schemaRef,
          });
          return {
            content: parserResult.output,
            contentType: parserResult.contentType,
            logs: parserResult.logs,
          };
        }
        case 'python': {
          const pythonConfig = (node.config.python ?? {}) as Record<string, unknown>;
          const code = String(pythonConfig.code ?? 'import json\nprint(json.dumps({"status": "ok"}))');
          const allowNetwork = Boolean(project?.settings?.allow_network);
          const result = await executePython({
            projectId,
            code,
            input: {
              node_id: node.node_id,
              inputs: previousNodes.map((n) => ({ node_id: n.node_id, content: n.content })),
            },
            allowNetwork,
          });
          const payload =
            typeof result.outputJson === 'string'
              ? result.outputJson
              : JSON.stringify(result.outputJson ?? { status: 'ok' }, null, 2);
          return {
            content: payload,
            contentType: 'application/json',
            logs: [`Python sandbox executed successfully`, result.stderr.trim()].filter(Boolean),
          };
        }
        case 'image_gen': {
          return {
            content: JSON.stringify({
              status: 'generated',
              prompt: node.meta?.prompt ?? 'image stub prompt',
              url: path.posix.join('/projects', projectId, 'project_output', `${node.node_id}.png`),
            }),
            contentType: 'application/json',
            logs: ['Image generation stub executed'],
          };
        }
        case 'audio_gen': {
          return {
            content: JSON.stringify({
              status: 'generated',
              text: node.meta?.script ?? 'audio stub script',
              url: path.posix.join('/projects', projectId, 'project_output', `${node.node_id}.wav`),
            }),
            contentType: 'application/json',
            logs: ['Audio generation stub executed'],
          };
        }
        case 'transformer': {
          const jsonContent = node.content ?? '';
          if (!jsonContent.trim()) {
            return {
              content: 'Transformer node requires JSON content with nodes',
              contentType: 'text/plain',
              logs: ['No JSON content provided for transformation'],
            };
          }
          
          try {
            // Позиция для создания нод - правее текущей ноды
            const startX = node.ui.bbox.x2 + 100;
            const startY = node.ui.bbox.y1;
            
            const transformResult = await this.transformerService.transformJsonToNodes(
              projectId,
              node.node_id,
              jsonContent,
              startX,
              startY
            );
            
            return {
              content: `🔄 Создано ${transformResult.createdNodes.length} нод: ${transformResult.createdNodes.map(n => n.title).join(', ')}`,
              contentType: 'text/plain',
              logs: transformResult.logs,
              createdNodes: transformResult.createdNodes,
              isMultiNodeResult: true,
            };
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Неизвестная ошибка';
            return {
              content: `❌ Ошибка трансформации: ${errorMessage}`,
              contentType: 'text/plain',
              logs: [`Transformer error: ${errorMessage}`],
            };
          }
        }
        case 'video_gen': {
          const videoResult = await generatePreviz({ projectId, nodeId: node.node_id });
          return {
            content: JSON.stringify({ status: 'generated', path: videoResult.videoPath }),
            contentType: 'application/json',
            logs: videoResult.logs,
          };
        }
        case 'html': {
          // HTML node output depends on its mode
          const htmlViewMode = node.meta?.htmlViewMode as string;
          const htmlUrl = node.meta?.htmlUrl as string;
          const htmlSourceCode = node.meta?.htmlSourceCode as string;
          
          if (htmlViewMode === 'code' && htmlSourceCode) {
            // In HTML mode, output the source code
            return {
              content: htmlSourceCode,
              contentType: 'text/html',
              logs: ['HTML node returned source code'],
            };
          } else if (htmlUrl) {
            // In render mode, output the URL
            return {
              content: htmlUrl,
              contentType: 'text/uri-list',
              logs: ['HTML node returned URL'],
            };
          }
          // Fallback to existing content
          return {
            content: node.content ?? '',
            contentType: node.content_type ?? 'text/html',
            logs: ['HTML node returned existing content'],
          };
        }
        case 'image_test': {
          // Create composite image: original image + annotation overlay
          const imageData = node.meta?.image_data as string;
          const annotationData = node.meta?.annotation_data as string;

          if (!imageData) {
            return {
              content: '',
              contentType: 'text/plain',
              logs: ['No image data found in image_test node'],
            };
          }

          if (!annotationData) {
            // Return original image if no annotations
            return {
              content: imageData,
              contentType: 'image/png',
              logs: ['Returning original image (no annotations)'],
            };
          }

          try {
            // For now, return the annotation data as the composite
            // TODO: Implement proper image compositing (original + annotation overlay)
            return {
              content: annotationData,
              contentType: 'image/png',
              logs: ['Returning annotation overlay as composite image'],
            };
          } catch (error) {
            console.error('Error creating composite image:', error);
            return {
              content: imageData,
              contentType: 'image/png',
              logs: ['Error creating composite image, returning original'],
            };
          }
        }
        case 'text':
        default: {
          return {
            content: node.content ?? '',
            contentType: node.content_type ?? 'text/plain',
            logs: ['Text node returned existing content'],
          };
        }
      }
    });

      const finishedAt = new Date().toISOString();
      const outputHash = hashContent(outcome.result.content ?? null);

      withTransaction(() => {
        // Only update content for non-AI nodes to preserve prompts
        if (node.type !== 'ai' && node.type !== 'ai_improved') {
          updateNodeContent(projectId, nodeId, {
            content: outcome.result.content ?? null,
            content_type: outcome.result.contentType ?? null,
          });
        }

        const metadataSnapshot = this.buildRunMetadataSnapshot(node, outcome.result);
        const createdNodeLogEntries = this.resolveCreatedNodeLogEntries(projectId, node, outcome.result);
        const predictionPayload = this.resolvePredictionPayload(node, outcome.result);
        const logPayload: Record<string, unknown> = {
          created_nodes: createdNodeLogEntries,
          status: 'success',
          engine: this.engineVersion,
          attempts: outcome.attempts,
          timeline: outcome.logs ?? [],
          node_logs: outcome.result.logs ?? [],
        };
        if (metadataSnapshot && Object.keys(metadataSnapshot).length > 0) {
          logPayload.metadata = metadataSnapshot;
        }
        if (predictionPayload !== undefined) {
          logPayload.prediction_payload = predictionPayload;
        }
        if (outcome.result.provider) {
          logPayload.provider = outcome.result.provider;
        }
        if (outcome.result.predictionId) {
          logPayload.prediction_id = outcome.result.predictionId;
        }

        storeRun({
          run_id: runId,
          project_id: projectId,
          node_id: nodeId,
          started_at: startedAt,
          finished_at: finishedAt,
          status: 'success',
          input_hash: hashContent(inputFingerprint),
          output_hash: outputHash,
          logs_json: JSON.stringify(logPayload),
        });
      });

      return {
        status: 'success' as const,
        nodeId,
        content: outcome.result.content ?? null,
        contentType: outcome.result.contentType ?? null,
        logs: [...outcome.logs, ...outcome.result.logs],
        runId,
        createdNodes: (outcome.result as any).createdNodes,
        createdNodeSnapshots: (outcome.result as any).createdNodeSnapshots,
        isMultiNodeResult: (outcome.result as any).isMultiNodeResult || false,
        predictionUrl: outcome.result.predictionUrl,
        predictionId: outcome.result.predictionId,
        provider: outcome.result.provider,
        predictionPayload: outcome.result.predictionPayload,
      };
    } catch (error) {
      const finishedAt = new Date().toISOString();
      const metadataSnapshot = this.buildRunMetadataSnapshot(node);
      const logPayload: Record<string, unknown> = {
        engine: this.engineVersion,
        status: 'failed',
        attempts: MAX_ATTEMPTS,
        errors: [(error as Error).message],
        logs: [(error as Error).message],
      };
      if (metadataSnapshot && Object.keys(metadataSnapshot).length > 0) {
        logPayload.metadata = metadataSnapshot;
      }

      withTransaction(() => {
        storeRun({
          run_id: runId,
          project_id: projectId,
          node_id: nodeId,
          started_at: startedAt,
          finished_at: finishedAt,
          status: 'failed',
          input_hash: hashContent(inputFingerprint),
          output_hash: hashContent({ error: (error as Error).message }),
          logs_json: JSON.stringify(logPayload),
        });
      });
      throw error;
    }
  }

  private buildExecutionContext(projectId: string, nodeId: string): ExecutionContext {
    const allNodes = new Map<string, StoredNode>();
    for (const node of listProjectNodes(projectId)) {
      allNodes.set(node.node_id, node);
    }

    const node = allNodes.get(nodeId);
    if (!node) {
      throw new Error(`Node ${nodeId} not found`);
    }

    const edges = listProjectEdges(projectId);
    const sorted = this.topologicalSort(allNodes, edges);
    if (sorted.hasCycle) {
      throw new Error('Graph contains cycles. Execution aborted');
    }

    return { projectId, node, allNodes, edges, sortedNodeIds: sorted.order };
  }

  private collectPreviousNodes(
    nodeId: string,
    order: string[],
    allNodes: Map<string, StoredNode>,
    edges: StoredEdge[],
    options?: { maxDepth?: number },
  ): StoredNode[] {
    const maxDepthRaw = options?.maxDepth;
    if (maxDepthRaw !== undefined && maxDepthRaw <= 0) {
      return [];
    }
    const maxDepth = maxDepthRaw ?? Number.POSITIVE_INFINITY;

    const adjacency = new Map<string, string[]>();
    for (const edge of edges) {
      const list = adjacency.get(edge.to_node) ?? [];
      list.push(edge.from_node);
      adjacency.set(edge.to_node, list);
    }

    const stack: Array<{ id: string; depth: number }> = (adjacency.get(nodeId) ?? []).map((from) => ({
      id: from,
      depth: 1,
    }));

    const seen = new Set<string>();
    const collected: Array<{ node: StoredNode; depth: number }> = [];

    while (stack.length) {
      const { id: currentId, depth } = stack.pop()!;
      if (depth > maxDepth) {
        continue;
      }
      if (seen.has(currentId)) {
        continue;
      }
      seen.add(currentId);

      const candidate = allNodes.get(currentId);
      if (!candidate) {
        continue;
      }

      collected.push({ node: candidate, depth });
      const upstream = adjacency.get(currentId) ?? [];
      for (const upstreamId of upstream) {
        stack.push({ id: upstreamId, depth: depth + 1 });
      }
    }

    if (collected.length === 0) {
      return [];
    }

    const orderIndex = new Map<string, number>();
    order.forEach((id, index) => orderIndex.set(id, index));

    collected.sort((a, b) => {
      const indexA = orderIndex.get(a.node.node_id) ?? Number.MAX_SAFE_INTEGER;
      const indexB = orderIndex.get(b.node.node_id) ?? Number.MAX_SAFE_INTEGER;
      if (indexA !== indexB) {
        return indexA - indexB;
      }
      return a.depth - b.depth;
    });

    const resolvedIds = new Set<string>();
    const resolved: StoredNode[] = [];

    const limitFromMeta = (meta: Record<string, unknown>): number => {
      const raw = meta.folder_context_limit;
      if (typeof raw === 'number' && Number.isFinite(raw)) {
        const normalized = Math.trunc(raw);
        if (normalized > 0 && normalized <= 24) {
          return normalized;
        }
      }
      return 6;
    };

    for (const { node: predecessor } of collected) {
      if (resolvedIds.has(predecessor.node_id)) {
        continue;
      }
      resolved.push(predecessor);
      resolvedIds.add(predecessor.node_id);

      if (predecessor.type === 'folder') {
        const folderMeta = (predecessor.meta ?? {}) as Record<string, unknown>;
        const children = Array.isArray(folderMeta.folder_children)
          ? (folderMeta.folder_children as unknown[]).filter((id): id is string => typeof id === 'string')
          : [];
        if (children.length > 0) {
          const limit = limitFromMeta(folderMeta);
          const slice = children.slice(-limit);
          for (const childId of slice) {
            if (resolvedIds.has(childId)) {
              continue;
            }
            const childNode = allNodes.get(childId);
            if (childNode) {
              resolved.push(childNode);
              resolvedIds.add(childId);
            }
          }
        }
      }
    }

    return resolved;
  }

  private collectNextNodeMetadata(
    nodeId: string,
    allNodes: Map<string, StoredNode>,
    edges: StoredEdge[],
    options?: { maxDepth?: number },
  ) {
    const maxDepthRaw = options?.maxDepth;
    if (maxDepthRaw !== undefined && maxDepthRaw <= 0) {
      return [];
    }
    const maxDepth = maxDepthRaw ?? Number.POSITIVE_INFINITY;

    const adjacency = new Map<string, StoredEdge[]>();
    for (const edge of edges) {
      const list = adjacency.get(edge.from_node) ?? [];
      list.push(edge);
      adjacency.set(edge.from_node, list);
    }

    const stack: Array<{ edge: StoredEdge; depth: number }> = (adjacency.get(nodeId) ?? []).map((edge) => ({
      edge,
      depth: 1,
    }));

    const seen = new Set<string>();
    const results: Array<{
      node_id: string;
      type: string;
      title: string;
      short_description: string;
      connection_labels: string[];
    }> = [];

    while (stack.length) {
      const { edge, depth } = stack.pop()!;
      if (depth > maxDepth) {
        continue;
      }

      const targetId = edge.to_node;
      if (seen.has(targetId)) {
        continue;
      }
      seen.add(targetId);

      const target = allNodes.get(targetId);
      results.push({
        node_id: targetId,
        type: target?.type ?? 'text',
        title: target?.title ?? 'Следующий узел',
        short_description: this.buildShortDescription(target),
        connection_labels: depth === 1 && edge.label ? [edge.label] : [],
      });

      const downstreamEdges = adjacency.get(targetId) ?? [];
      downstreamEdges.forEach((nextEdge) => {
        stack.push({ edge: nextEdge, depth: depth + 1 });
      });
    }

    return results;
  }

  private normalizeContextDepthValue(raw: unknown, fallback: number): number {
    const maxSupportedDepth = 10; // Updated to 10 as per requirements
    if (typeof raw === 'number' && Number.isFinite(raw)) {
      return Math.max(0, Math.min(maxSupportedDepth, Math.trunc(raw)));
    }
    if (typeof raw === 'string') {
      const parsed = Number.parseInt(raw, 10);
      if (Number.isFinite(parsed)) {
        return Math.max(0, Math.min(maxSupportedDepth, Math.trunc(parsed)));
      }
    }
    return Math.max(0, Math.min(maxSupportedDepth, Math.trunc(fallback)));
  }

  /**
   * Format node for context based on mode (simple or full_json)
   */
  private formatNodeForContext(
    node: StoredNode,
    mode: 'simple' | 'full_json'
  ): string {
    const MAX_JSON_SIZE = 50 * 1024; // 50KB limit for full_json mode
    
    if (mode === 'full_json') {
      const fullJson = JSON.stringify(node, null, 2);
      
      // Truncate if too large
      if (fullJson.length > MAX_JSON_SIZE) {
        const truncated = fullJson.substring(0, MAX_JSON_SIZE);
        return truncated + '\n\n[...truncated - node JSON exceeds 50KB]';
      }
      
      return fullJson;
    }
    
    // Simple mode - format based on node type
    const parts: string[] = [];
    parts.push(`Context from "${node.title || node.node_id}":`);
    
    switch (node.type) {
      case 'text': {
        if (node.content) {
          parts.push(node.content);
        }
        break;
      }
      
      case 'image': {
        const meta = (node.meta ?? {}) as Record<string, unknown>;
        const imageUrl = meta?.image_url || meta?.original_image;
        parts.push(`Image: ${node.title || 'Untitled'}`);
        if (imageUrl && typeof imageUrl === 'string') {
          parts.push(`URL: ${imageUrl}`);
        }
        break;
      }
      
      case 'video': {
        const meta = (node.meta ?? {}) as Record<string, unknown>;
        const videoUrl = meta?.video_url;
        parts.push(`Video: ${node.title || 'Untitled'}`);
        if (videoUrl && typeof videoUrl === 'string') {
          parts.push(`URL: ${videoUrl}`);
        }
        break;
      }
      
      case 'pdf':
      case 'file': {
        const meta = (node.meta ?? {}) as Record<string, unknown>;
        const fileUrl = meta?.file_url || meta?.pdf_url;
        parts.push(`File: ${node.title || 'Untitled'}`);
        if (fileUrl && typeof fileUrl === 'string') {
          parts.push(`URL: ${fileUrl}`);
        }
        if (node.content) {
          parts.push(`Content: ${node.content}`);
        }
        break;
      }
      
      case 'code': {
        parts.push(`Code: ${node.title || 'Untitled'}`);
        if (node.content) {
          parts.push('```');
          parts.push(node.content);
          parts.push('```');
        }
        break;
      }
      
      case 'ai':
      case 'ai_improved': {
        parts.push(`AI Node: ${node.title || 'Untitled'}`);
        if (node.content) {
          parts.push(node.content);
        }
        break;
      }
      
      default: {
        // For other types, include title and content if available
        if (node.content) {
          parts.push(node.content);
        } else {
          const meta = (node.meta ?? {}) as Record<string, unknown>;
          if (meta && Object.keys(meta).length > 0) {
            parts.push(`Type: ${node.type}`);
            parts.push(`Meta: ${JSON.stringify(meta, null, 2)}`);
          }
        }
        break;
      }
    }
    
    return parts.join('\n');
  }

  private buildShortDescription(node?: StoredNode): string {
    if (!node) return 'Нет данных';
    const base = node.meta?.short_description ?? node.content ?? node.title;
    return String(base ?? node.title).substring(0, 200);
  }

  private async withRetry<T>(fn: () => Promise<T>): Promise<RetryOutcome<T>> {
    const logs: string[] = [];
    let lastError: unknown;
    for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt += 1) {
      try {
        if (BACKOFF[attempt]) {
          logs.push(`Retry backoff ${BACKOFF[attempt]}ms before attempt ${attempt + 1}`);
          await new Promise((resolve) => setTimeout(resolve, BACKOFF[attempt]));
        }
        const result = await fn();
        return { result, attempts: attempt + 1, logs };
      } catch (error) {
        lastError = error;
        logs.push(`Attempt ${attempt + 1} failed: ${(error as Error).message}`);
      }
    }
    const message = lastError instanceof Error ? lastError.message : 'Unknown error';
    throw new Error(`Execution failed after ${MAX_ATTEMPTS} attempts: ${message}`);
  }

  private topologicalSort(allNodes: Map<string, StoredNode>, edges: StoredEdge[]): {
    order: string[];
    hasCycle: boolean;
  } {
    const indegree = new Map<string, number>();
    const adjacency = new Map<string, string[]>();

    for (const nodeId of allNodes.keys()) {
      indegree.set(nodeId, 0);
      adjacency.set(nodeId, []);
    }

    for (const edge of edges) {
      if (!indegree.has(edge.to_node)) {
        indegree.set(edge.to_node, 0);
      }
      indegree.set(edge.to_node, (indegree.get(edge.to_node) ?? 0) + 1);
      const list = adjacency.get(edge.from_node) ?? [];
      list.push(edge.to_node);
      adjacency.set(edge.from_node, list);
    }

    const queue: string[] = [];
    for (const [nodeId, degree] of indegree.entries()) {
      if (degree === 0) queue.push(nodeId);
    }

    const order: string[] = [];
    while (queue.length) {
      const current = queue.shift()!;
      order.push(current);
      for (const neighbor of adjacency.get(current) ?? []) {
        const next = (indegree.get(neighbor) ?? 0) - 1;
        indegree.set(neighbor, next);
        if (next === 0) queue.push(neighbor);
      }
    }

    const hasCycle = order.length !== allNodes.size;
    return { order, hasCycle };
  }

  protected async createReplicateAssetNodes(
    projectId: string,
    sourceNode: StoredNode,
    rawOutputs: unknown[],
    predictionId?: string,
    predictionUrl?: string,
  ): Promise<{ createdNodes: CreatedNodeSummary[]; nodeSnapshots: CreatedNodeSnapshot[]; logs: string[] }> {
    console.log('[DEBUG] ===== createReplicateAssetNodes CALLED =====');
    console.log('[DEBUG] rawOutputs length:', rawOutputs.length);
    console.log('[DEBUG] rawOutputs:', JSON.stringify(rawOutputs, null, 2));
    console.log('[DEBUG] predictionId:', predictionId);
    console.log('[DEBUG] predictionUrl:', predictionUrl);
    console.log('[DEBUG] sourceNode.node_id:', sourceNode.node_id);
    console.log('[DEBUG] Timestamp:', new Date().toISOString());
    
    // 🛡️ GUARD: Проверка что prediction еще не обрабатывается (Promise-based для async safety)
    if (predictionId) {
      // Если уже есть промис обработки - дождаться его и вернуть результат
      const existingPromise = ExecutorService.processingPromises.get(predictionId);
      if (existingPromise) {
        console.log('[DEBUG] ⚠️ WAIT: prediction already processing, waiting for result:', predictionId);
        const result = await existingPromise;
        console.log('[DEBUG] ⚠️ SKIP: returning cached result from first call');
        return result;
      }
      
      console.log('[DEBUG] ✅ First call for predictionId:', predictionId);
    }

    // Создаем промис для этой обработки
    const processingPromise = (async () => {
      try {
      // Special handling for Replicate API responses
      const processedOutputs: unknown[] = [];
    for (const output of rawOutputs) {
      if (output && typeof output === 'object' && !Array.isArray(output)) {
        const record = output as Record<string, unknown>;
        console.log('[DEBUG] Processing output object:', record);

        // Check if this looks like a Replicate prediction response
        if (record.status === 'succeeded' && typeof record.output === 'string') {
          console.log('[DEBUG] Found succeeded status with output URL:', record.output);
          processedOutputs.push(record.output);
        } else if (record.output) {
          console.log('[DEBUG] Found output field, adding as is:', record.output);
          processedOutputs.push(record.output);
        } else {
          console.log('[DEBUG] Adding raw output as is:', output);
          processedOutputs.push(output);
        }
      } else {
        console.log('[DEBUG] Adding non-object output as is:', output);
        processedOutputs.push(output);
      }
    }

    const sources = processedOutputs
      .filter((value) => value !== null && value !== undefined)
      .map((value) => (typeof value === 'string' ? value.trim() : value))
      .filter((value) => (typeof value === 'string' ? value.length > 0 : true));

    console.log('[DEBUG] Normalized sources for artifacts:', sources);

    const artifacts = sources.flatMap((value) => this.normalizeReplicateArtifacts(value));
    console.log('[DEBUG] Artifacts after normalization:', artifacts);

    if (artifacts.length === 0) {
      return {
        createdNodes: [],
        nodeSnapshots: [],
        logs: [
          `Replicate output did not contain assets (sources inspected: ${sources.length}).`,
        ],
      };
    }

    const created: CreatedNodeSummary[] = [];
    const snapshots: CreatedNodeSnapshot[] = [];
    const logs: string[] = [];
    const timestamp = new Date().toISOString();

    const downstreamTargetIds = new Set(
      listProjectEdges(projectId)
        .filter((edge) => edge.from_node === sourceNode.node_id)
        .map((edge) => edge.to_node),
    );

    const downstreamNodes = listProjectNodes(projectId).filter((node) =>
      downstreamTargetIds.has(node.node_id),
    );

    const existingSignatures = new Set<string>();
    const registerSignature = (kind: string, value: string | null | undefined) => {
      if (typeof value !== 'string') {
        return;
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return;
      }
      existingSignatures.add(`${kind}:${trimmed}`);
    };

    console.log('[DEBUG] createReplicateAssetNodes - checking duplicates');
    console.log('[DEBUG] predictionId:', predictionId);
    console.log('[DEBUG] sourceNode.node_id:', sourceNode.node_id);
    console.log('[DEBUG] downstreamNodes count:', downstreamNodes.length);

    for (const node of downstreamNodes) {
      const meta = (node.meta ?? {}) as Record<string, unknown>;
      
      console.log('[DEBUG] Checking downstream node:', {
        nodeId: node.node_id,
        type: node.type,
        sourcePredictionId: meta.source_prediction_id,
        sourceNodeId: meta.source_node_id,
        sourceProvider: meta.source_provider,
        imageUrl: meta.image_url,
        originalUrl: meta.original_url,
        videoUrl: meta.video_url,
      });
      
      // ✅ ИСПРАВЛЕНО: упрощенная проверка - пропускать только если явно принадлежит другому prediction
      if (
        predictionId &&
        typeof meta.source_prediction_id === 'string' &&
        meta.source_prediction_id !== predictionId
      ) {
        console.log('[DEBUG] Skipping node - different predictionId');
        continue;
      }
      
      // ✅ ИСПРАВЛЕНО: НЕ пропускать ноды без predictionId при перезагрузке
      // Старая логика блокировала дедупликацию при перезагрузке страницы
      // if (!predictionId && typeof meta.source_node_id === 'string' && meta.source_node_id !== sourceNode.node_id) {
      //   continue;
      // }
      
      // ✅ ИСПРАВЛЕНО: проверять только source_provider для безопасности
      if (
        typeof meta.source_provider === 'string' &&
        meta.source_provider !== 'replicate'
      ) {
        console.log('[DEBUG] Skipping node - not from replicate');
        continue;
      }

      switch (node.type) {
        case 'image': {
          registerSignature('image', meta.image_url as string);
          registerSignature('image', meta.original_url as string); // ← Replicate URL после автоскачивания!
          registerSignature('image', meta.original_image as string);
          registerSignature('image', meta.annotated_image as string);
          registerSignature('image', meta.image_data as string);
          registerSignature('image', node.content);
          break;
        }
        case 'video': {
          registerSignature('video', meta.video_url as string);
          registerSignature('video', meta.original_url as string); // ← Replicate URL после автоскачивания!
          registerSignature('video', meta.video_data as string);
          registerSignature('video', node.content);
          break;
        }
        case 'text': {
          registerSignature('text', node.content);
          break;
        }
        default:
          break;
      }
    }

    console.log('[DEBUG] existingSignatures:', Array.from(existingSignatures));

    let duplicateCount = 0;
    
    // 🔑 Set для отслеживания созданных assetId ВНУТРИ этого вызова
    const createdAssetIds = new Set<string>();

    const buildTitle = (artifact: { kind: 'text' | 'image' | 'video'; title?: string }, offset: number) => {
      if (artifact.title && artifact.title.trim()) {
        return artifact.title.trim();
      }
      const names: Record<typeof artifact.kind, string> = {
        image: 'Replicate Image',
        video: 'Replicate Video',
        text: 'Replicate Text',
      };
      return `${names[artifact.kind]} ${offset + 1}`;
    };

    withTransaction(async () => {
      for (const [index, artifact] of artifacts.entries()) {
        console.log(`[DEBUG] createReplicateAssetNodes - processing artifact ${index + 1}/${artifacts.length}:`, { 
          kind: artifact.kind, 
          value: artifact.value.slice(0, 100),
          title: artifact.title 
        });

        const rawValue = typeof artifact.value === 'string' ? artifact.value.trim() : '';
        if (!rawValue) {
          logs.push('Replicate: пропущен пустой артефакт.');
          console.log('[DEBUG] createReplicateAssetNodes - skipping empty artifact');
          continue;  // Пропустить пустой артефакт и продолжить обработку следующих
        }

        // 🔑 Уникальный ID для артефакта: predictionId + index
        const assetId = predictionId ? `${predictionId}_${index}` : `${sourceNode.node_id}_${index}_${Date.now()}`;
        
        // 🛡️ ПРОВЕРКА #1: По replicate_asset_id в уже созданных нодах ВНУТРИ этого цикла
        if (createdAssetIds.has(assetId)) {
          console.log(`[DEBUG] ⚠️ SKIP: Asset already created in this cycle:`, assetId);
          duplicateCount += 1;
          logs.push(`Replicate: пропуск ${artifact.kind}-артефакта (дубль в цикле).`);
          continue;
        }
        
        // 🛡️ ПРОВЕРКА #2: По replicate_asset_id в downstreamNodes (из БД)
        const isDuplicateById = downstreamNodes.some((n) => {
          const nmeta = (n.meta ?? {}) as Record<string, unknown>;
          return nmeta.replicate_asset_id === assetId;
        });
        
        if (isDuplicateById) {
          console.log(`[DEBUG] ⚠️ SKIP: Node with asset_id already exists in DB:`, assetId);
          duplicateCount += 1;
          logs.push(`Replicate: пропуск ${artifact.kind}-артефакта (дубль по asset_id).`);
          continue;
        }
        
        // 🛡️ ПРОВЕРКА #2: По signature (URL/content)
        const signature = `${artifact.kind}:${rawValue}`;
        if (existingSignatures.has(signature)) {
          duplicateCount += 1;
          logs.push(`Replicate: пропуск ${artifact.kind}-артефакта, найден дубликат.`);
          console.log('[DEBUG] createReplicateAssetNodes - skipping duplicate artifact');
          continue;  // Пропустить дубликат и продолжить обработку следующих артефактов
        }
        
        // 🛡️ ПРОВЕРКА #3: Дополнительная проверка по всем возможным URL
        const existingNode = downstreamNodes.find((n) => {
          const nmeta = (n.meta ?? {}) as Record<string, unknown>;
          return (
            nmeta.image_url === rawValue ||        // localhost URL (после автоскачивания)
            nmeta.original_url === rawValue ||     // Replicate URL
            nmeta.video_url === rawValue ||        // video URL
            n.content === rawValue                 // Fallback
          );
        });

        if (existingNode) {
          console.log('[DEBUG] ⚠️ SKIP: Node already exists by URL:', {
            existingNodeId: existingNode.node_id,
            assetId,
            rawValue: rawValue.slice(0, 80),
          });
          duplicateCount += 1;
          logs.push(`Replicate: пропуск ${artifact.kind}-артефакта (дубль по URL).`);
          continue;
        }

        const position = this.deriveReplicateAssetPosition(sourceNode, created.length);
        const baseMeta: Record<string, unknown> = {
          replicate_asset_id: assetId, // 🔑 КРИТИЧНО для дедупликации!
          source_prediction_id: predictionId,
          source_prediction_url: predictionUrl,
          source_provider: 'replicate',
          source_node_id: sourceNode.node_id,
          source_node_title: sourceNode.title,
          source_artifact_kind: artifact.kind,
          artifact_value_preview: rawValue.slice(0, 180),
          asset_index: created.length,
          created_at: timestamp,
        };

        const title = buildTitle(artifact, created.length);
        const nodeInputMeta: Record<string, unknown> = { ...baseMeta };
        let content = '';
        let contentType: string | null = null;

        if (artifact.kind === 'image') {
          const isDataUri = this.isDataUri(rawValue);
          if (!isDataUri) {
            nodeInputMeta.image_url = rawValue;
          } else {
            nodeInputMeta.image_data = rawValue;
            nodeInputMeta.display_mode = 'upload';
          }
          nodeInputMeta.original_image = rawValue;
          nodeInputMeta.annotated_image = rawValue;
          nodeInputMeta.view_mode = 'original';
          nodeInputMeta.image_output_mode = 'original';
          contentType = isDataUri ? 'image/data-uri' : 'image/url';
        } else if (artifact.kind === 'video') {
          const isDataUri = this.isDataUri(rawValue);
          if (!isDataUri) {
            nodeInputMeta.video_url = rawValue;
            nodeInputMeta.display_mode = 'url';
          } else {
            nodeInputMeta.video_data = rawValue;
            nodeInputMeta.display_mode = 'upload';
          }
          nodeInputMeta.controls = true;
          contentType = isDataUri ? 'video/data-uri' : 'video/url';
        } else {
          content = rawValue;
          contentType = 'text/plain';
          nodeInputMeta.text_origin = 'replicate_artifact';
        }

        console.log('[DEBUG] createReplicateAssetNodes - creating node:', {
          type: artifact.kind,
          title,
          contentType,
          hasImageUrl: !!nodeInputMeta.image_url,
          hasVideoUrl: !!nodeInputMeta.video_url,
          metaKeys: Object.keys(nodeInputMeta)
        });

        // Auto-download media files from Replicate to local storage
        let finalMeta = nodeInputMeta;
        if (artifact.kind === 'image' || artifact.kind === 'video') {
          try {
            console.log(`[DEBUG] Attempting auto-download for Replicate artifact: ${rawValue.slice(0, 100)}`);
            
            const downloadResult = await autoDownloadMediaIfNeeded(
              projectId,
              artifact.kind,
              nodeInputMeta
            );

            if (downloadResult.downloaded) {
              finalMeta = downloadResult.updatedMeta;
              
              // ✅ КРИТИЧНО: сохранить original_url для дедупликации при перезагрузке!
              if (!finalMeta.original_url && rawValue.startsWith('http')) {
                finalMeta.original_url = rawValue; // ← Replicate URL
              }
              
              const urlField = artifact.kind === 'image' ? 'image_url' : 'video_url';
              const localUrl = finalMeta[urlField] as string;
              
              console.log(`[DEBUG] Auto-downloaded Replicate artifact to: ${localUrl}`);
              console.log(`[DEBUG] Saved original_url for deduplication: ${finalMeta.original_url}`);
              logs.push(`Replicate: файл скачан на сервер (${Math.round((finalMeta.file_size as number) / 1024)}KB)`);
            } else if (downloadResult.updatedMeta.auto_download_skipped) {
              logs.push(`Replicate: скачивание пропущено (${downloadResult.updatedMeta.skip_reason})`);
            } else if (downloadResult.updatedMeta.auto_download_failed) {
              logs.push(`Replicate: ошибка скачивания (${downloadResult.updatedMeta.download_error})`);
            }
          } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            console.error(`[DEBUG] Auto-download failed for Replicate artifact:`, errorMsg);
            logs.push(`Replicate: ошибка скачивания (${errorMsg})`);
            // Continue with original URL - node creation should not fail
          }
        }

        const { node } = createProjectNode(
          projectId,
          {
            type: artifact.kind,
            title,
            content,
            content_type: contentType,
            meta: finalMeta,
          },
          { position },
        );

        console.log('[DEBUG] createReplicateAssetNodes - node created:', {
          node_id: node.node_id,
          type: node.type,
          title: node.title
        });

        addProjectEdge(projectId, {
          from: sourceNode.node_id,
          to: node.node_id,
          label: 'asset',
        });

        // 🔑 КРИТИЧНО: Добавляем assetId в Set чтобы следующие артефакты не создали дубль
        createdAssetIds.add(assetId);
        existingSignatures.add(signature);
        created.push({ node_id: node.node_id, type: node.type, title: node.title });
        
        // Use finalMeta (after auto-download) for snapshot to ensure logs show correct URLs
        const snapshotMeta = this.extractNodeMetaSnapshot(finalMeta, artifact.kind, rawValue);
        const snapshotUiPos = this.safeExtractUiPosition(finalMeta);
        snapshots.push({
          node_id: node.node_id,
          type: node.type,
          title: node.title,
          content_type: node.content_type ?? null,
          ui_position: snapshotUiPos,
          meta: snapshotMeta,
        });
        logs.push(`Replicate: создана ${artifact.kind}-нода "${node.title}" (${node.node_id}).`);
      }
    });

    if (duplicateCount > 0) {
      logs.push(`Replicate: пропущено ${duplicateCount} артефакт(ов) как дубликаты.`);
    }
    if (created.length > 0) {
      const byType = new Map<string, number>();
      created.forEach((node) => {
        byType.set(node.type, (byType.get(node.type) ?? 0) + 1);
      });
      const parts = Array.from(byType.entries()).map(([type, count]) => `${count} ${this.describeArtifactPlural(type, count)}`);
      logs.push(`Replicate: создано ${created.length} нод (${parts.join(', ')}).`);
    } else if (duplicateCount === 0) {
      logs.push('Replicate: новые артефакты не найдены.');
    }

    if (predictionId) {
      logs.push(`Replicate meta: prediction_id=${predictionId}`);
    }
    if (predictionUrl) {
      logs.push(`Replicate meta: prediction_url=${predictionUrl}`);
    }
    const artifactOutputs = artifacts
      .filter((artifact) => artifact.kind === 'image' || artifact.kind === 'video')
      .map((artifact) => artifact.value)
      .filter((value, index, self) => self.indexOf(value) === index);
    if (artifactOutputs.length > 0) {
      logs.push(`Replicate outputs: ${artifactOutputs.join(', ')}`);
    }

        return { createdNodes: created, nodeSnapshots: snapshots, logs };
      } finally {
        // Очистка guard после завершения (успешного или с ошибкой)
        if (predictionId) {
          ExecutorService.processingPromises.delete(predictionId);
          ExecutorService.processingPredictions.delete(predictionId);
          console.log('[DEBUG] 🧹 Removed from processingPromises:', predictionId);
        }
      }
    })();
    
    // Сохраняем промис для других вызовов
    if (predictionId) {
      ExecutorService.processingPromises.set(predictionId, processingPromise);
    }
    
    return processingPromise;
  } // END createReplicateAssetNodes

  private normalizeMetaRecord(meta: unknown): Record<string, unknown> {
    if (meta && typeof meta === 'object' && !Array.isArray(meta)) {
      return { ...(meta as Record<string, unknown>) };
    }
    return {};
  }

  private sanitizeMetaSnapshot(meta: Record<string, unknown>): Record<string, unknown> {
    const allowed: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(meta)) {
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) {
          continue;
        }
        if (trimmed.length > 2048) {
          if (this.isDataUri(trimmed)) {
            continue;
          }
          allowed[key] = `${trimmed.slice(0, 200)}…`;
        } else {
          allowed[key] = trimmed;
        }
      } else if (typeof value === 'number' || typeof value === 'boolean') {
        allowed[key] = value;
      }
    }
    return allowed;
  }

  private extractNodeMetaSnapshot(
    meta: Record<string, unknown>,
    artifactKind: 'text' | 'image' | 'video',
    rawValue?: string,
  ): Record<string, unknown> {
    const snapshot: Record<string, unknown> = {};
    const sourceKeys = [
      'source_provider',
      'source_prediction_id',
      'source_prediction_url',
      'source_node_id',
      'source_node_title',
      'asset_index',
      'artifact_value_preview',
      'display_mode',
      'view_mode',
      'image_output_mode',
    ];
    for (const key of sourceKeys) {
      const value = meta[key];
      if (typeof value === 'string' && value.trim()) {
        snapshot[key] = key.includes('url') && !this.isLikelyUrl(value) && !this.isDataUri(value) ? undefined : value.trim();
      } else if (typeof value === 'number' || typeof value === 'boolean') {
        snapshot[key] = value;
      }
    }

    const linkKeys =
      artifactKind === 'image'
        ? ['image_url', 'original_image', 'annotated_image']
        : artifactKind === 'video'
          ? ['video_url']
          : ['text_preview'];
    for (const key of linkKeys) {
      const value = meta[key];
      if (typeof value === 'string' && value.trim()) {
        if (this.isLikelyUrl(value) || this.isDataUri(value)) {
          snapshot[key] = value.trim();
        } else if (key === 'text_preview') {
          snapshot[key] = value.slice(0, 280);
        }
      }
    }

    if (!snapshot.artifact_value_preview && typeof rawValue === 'string' && rawValue.trim()) {
      snapshot.artifact_value_preview = rawValue.trim().slice(0, 280);
    }

    return this.sanitizeMetaSnapshot(snapshot);
  }

  private safeExtractUiPosition(meta: Record<string, unknown>): { x: number; y: number } | null {
    const raw = meta.ui_position;
    if (raw && typeof raw === 'object' && !Array.isArray(raw)) {
      const x = Number((raw as Record<string, unknown>).x);
      const y = Number((raw as Record<string, unknown>).y);
      if (Number.isFinite(x) && Number.isFinite(y)) {
        return { x: Math.round(x), y: Math.round(y) };
      }
    }
    return null;
  }

  private pickPrimaryLinkFromSnapshot(snapshot?: CreatedNodeSnapshot): string | undefined {
    if (!snapshot?.meta) {
      return undefined;
    }
    const candidates = ['image_url', 'original_image', 'annotated_image', 'video_url', 'text_preview'];
    for (const key of candidates) {
      const value = snapshot.meta[key];
      if (typeof value === 'string' && value.trim()) {
        const trimmed = value.trim();
        if (key === 'text_preview') {
          continue;
        }
        if (this.isLikelyUrl(trimmed) || this.isDataUri(trimmed)) {
          return trimmed;
        }
      }
    }
    return undefined;
  }

  private applyCreatedNodesToMeta(
    projectId: string,
    node: StoredNode,
    createdSnapshots: CreatedNodeSnapshot[],
    options?: { predictionPayload?: unknown },
  ): void {
    const currentMeta = this.normalizeMetaRecord(node.meta);
    const nextMeta: Record<string, unknown> = { ...currentMeta };

    if (createdSnapshots.length > 0) {
      nextMeta.created_nodes = createdSnapshots.map((snapshot) => {
        const entry: Record<string, unknown> = {
          node_id: snapshot.node_id,
          type: snapshot.type,
          title: snapshot.title,
        };
        if (snapshot.content_type) {
          entry.content_type = snapshot.content_type;
        }
        if (snapshot.ui_position) {
          entry.ui_position = snapshot.ui_position;
        }
        if (snapshot.meta) {
          entry.meta = snapshot.meta;
        }
        return entry;
      });

      const primarySnapshot = createdSnapshots[0];
      if (
        typeof nextMeta.output_type !== 'string' ||
        !nextMeta.output_type ||
        nextMeta.output_type === 'node'
      ) {
        nextMeta.output_type = primarySnapshot?.type ?? 'node';
      }
      const primaryLink = this.pickPrimaryLinkFromSnapshot(primarySnapshot);
      if (primaryLink) {
        nextMeta.replicate_output = primaryLink;
      }
    }

    if (options?.predictionPayload !== undefined) {
      nextMeta.replicate_prediction_payload = options.predictionPayload;
    }

    updateNodeMetaSystem(projectId, node.node_id, nextMeta);
    node.meta = nextMeta;
  }

  private buildCreatedNodeSnapshotFromStored(stored: StoredNode): CreatedNodeSnapshot {
    const metaRecord = this.normalizeMetaRecord(stored.meta);
    const kind: 'text' | 'image' | 'video' =
      stored.type === 'image' || stored.type === 'video' ? (stored.type as 'image' | 'video') : 'text';
    const snapshotMeta = this.extractNodeMetaSnapshot(metaRecord, kind);
    return this.sanitizeCreatedNodeSnapshot({
      node_id: stored.node_id,
      type: stored.type,
      title: stored.title,
      content_type: stored.content_type ?? null,
      ui_position: this.safeExtractUiPosition(metaRecord),
      meta: snapshotMeta,
    });
  }

  private sanitizeCreatedNodeSnapshot(snapshot: CreatedNodeSnapshot): CreatedNodeSnapshot {
    const result: CreatedNodeSnapshot = {
      node_id: snapshot.node_id,
      type: snapshot.type,
      title: snapshot.title,
    };
    if (snapshot.content_type) {
      result.content_type = snapshot.content_type;
    }
    if (snapshot.ui_position) {
      result.ui_position = {
        x: Math.round(snapshot.ui_position.x),
        y: Math.round(snapshot.ui_position.y),
      };
    }
    if (snapshot.meta) {
      result.meta = this.sanitizeMetaSnapshot(snapshot.meta);
    }
    return result;
  }

  private normalizeMetaCreatedNode(entry: unknown): CreatedNodeSnapshot | null {
    if (!entry || typeof entry !== 'object' || Array.isArray(entry)) {
      return null;
    }
    const record = entry as Record<string, unknown>;
    const nodeId = typeof record.node_id === 'string' ? record.node_id : null;
    const type = typeof record.type === 'string' ? record.type : null;
    const title = typeof record.title === 'string' ? record.title : null;
    if (!nodeId || !type || !title) {
      return null;
    }
    const snapshot: CreatedNodeSnapshot = {
      node_id: nodeId,
      type,
      title,
    };
    if (typeof record.content_type === 'string') {
      snapshot.content_type = record.content_type;
    }
    if (record.ui_position && typeof record.ui_position === 'object' && !Array.isArray(record.ui_position)) {
      const x = Number((record.ui_position as Record<string, unknown>).x);
      const y = Number((record.ui_position as Record<string, unknown>).y);
      if (Number.isFinite(x) && Number.isFinite(y)) {
        snapshot.ui_position = { x: Math.round(x), y: Math.round(y) };
      }
    }
    if (record.meta && typeof record.meta === 'object' && !Array.isArray(record.meta)) {
      snapshot.meta = this.sanitizeMetaSnapshot(record.meta as Record<string, unknown>);
    }
    return snapshot;
  }

  private resolveCreatedNodeLogEntries(
    projectId: string,
    node: StoredNode,
    result: Partial<ExecutionStepResult>,
  ): CreatedNodeSnapshot[] {
    if (result.createdNodeSnapshots && result.createdNodeSnapshots.length > 0) {
      return result.createdNodeSnapshots.map((snapshot) => this.sanitizeCreatedNodeSnapshot(snapshot));
    }
    if (result.createdNodes && result.createdNodes.length > 0) {
      const entries: CreatedNodeSnapshot[] = [];
      for (const summary of result.createdNodes) {
        const stored = getNode(projectId, summary.node_id);
        if (stored) {
          entries.push(this.buildCreatedNodeSnapshotFromStored(stored));
        } else {
          entries.push(
            this.sanitizeCreatedNodeSnapshot({
              node_id: summary.node_id,
              type: summary.type,
              title: summary.title,
            }),
          );
        }
      }
      return entries;
    }
    const meta = this.normalizeMetaRecord(node.meta);
    const createdFromMeta = Array.isArray(meta.created_nodes) ? meta.created_nodes : [];
    if (createdFromMeta.length > 0) {
      return createdFromMeta
        .map((entry) => this.normalizeMetaCreatedNode(entry))
        .filter((entry): entry is CreatedNodeSnapshot => entry !== null)
        .map((entry) => this.sanitizeCreatedNodeSnapshot(entry));
    }
    return [];
  }

  private resolvePredictionPayload(
    node: StoredNode,
    result: Partial<ExecutionStepResult>,
  ): unknown {
    if (result.predictionPayload !== undefined) {
      return result.predictionPayload;
    }
    const meta = this.normalizeMetaRecord(node.meta);
    if (meta.replicate_prediction_payload !== undefined) {
      return meta.replicate_prediction_payload;
    }
    return undefined;
  }

  private collectReplicateOutputCandidates(
    result: {
      output: string;
      rawOutput?: unknown;
      predictionPayload?: unknown;
    },
    parsedOutput: unknown,
  ): unknown[] {
    console.log('[DEBUG] collectReplicateOutputCandidates - input result.output:', result.output);
    console.log('[DEBUG] collectReplicateOutputCandidates - input parsedOutput:', parsedOutput);
    console.log('[DEBUG] collectReplicateOutputCandidates - input result.rawOutput:', result.rawOutput);
    console.log('[DEBUG] collectReplicateOutputCandidates - input result.predictionPayload:', result.predictionPayload);

    const candidates: unknown[] = [];
    const stringSeen = new Set<string>();
    const objectSeen = new WeakSet<Record<string, unknown>>();

    const register = (value: unknown): void => {
      if (value === null || value === undefined) {
        return;
      }
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed || stringSeen.has(trimmed)) {
          return;
        }
        stringSeen.add(trimmed);
        candidates.push(trimmed);
        console.log('[DEBUG] collectReplicateOutputCandidates - registered string:', trimmed.slice(0, 100));
        return;
      }
      if (typeof value === 'object') {
        const record = value as Record<string, unknown>;
        if (objectSeen.has(record)) {
          return;
        }
        objectSeen.add(record);
        candidates.push(record);
        console.log('[DEBUG] collectReplicateOutputCandidates - registered object with keys:', Object.keys(record));
        return;
      }
      candidates.push(value);
    };

    // Register parsedOutput first (which should be the parsed JSON object)
    // If parsedOutput exists, we should NOT register result.output (it's a JSON string)
    const hasParsedOutput = parsedOutput !== undefined && parsedOutput !== null && 
      (typeof parsedOutput === 'object' || typeof parsedOutput === 'string' && parsedOutput.trim().length > 0);
    
    console.log('[DEBUG] collectReplicateOutputCandidates - hasParsedOutput:', hasParsedOutput);
    
    if (hasParsedOutput) {
      register(parsedOutput);
    }
    register(result.predictionPayload);
    register(result.rawOutput);
    // Only register result.output if we don't have parsedOutput
    if (!hasParsedOutput) {
      console.log('[DEBUG] collectReplicateOutputCandidates - no parsedOutput, registering result.output');
      register(result.output);
    } else {
      console.log('[DEBUG] collectReplicateOutputCandidates - parsedOutput exists, skipping result.output');
    }

    const primary = this.extractPrimaryReplicateOutput(candidates);
    console.log('[DEBUG] collectReplicateOutputCandidates - primary output:', primary);
    if (primary && !stringSeen.has(primary)) {
      stringSeen.add(primary);
      candidates.push(primary);
    }

    console.log('[DEBUG] collectReplicateOutputCandidates - total candidates:', candidates.length);
    return candidates;
  }

  private extractPrimaryReplicateOutput(output: unknown, depth = 0): string {
    if (depth > 5 || output === null || output === undefined) {
      return '';
    }
    if (typeof output === 'string') {
      return output.trim();
    }
    if (Array.isArray(output)) {
      for (const item of output) {
        const candidate = this.extractPrimaryReplicateOutput(item, depth + 1);
        if (candidate) {
          return candidate;
        }
      }
      return '';
    }
    if (typeof output === 'object') {
      const record = output as Record<string, unknown>;
      if (typeof record.output === 'string' && record.output.trim()) {
        return record.output.trim();
      }
      if (record.output !== undefined) {
        const nested = this.extractPrimaryReplicateOutput(record.output, depth + 1);
        if (nested) {
          return nested;
        }
      }
      for (const value of Object.values(record)) {
        const candidate = this.extractPrimaryReplicateOutput(value, depth + 1);
        if (candidate) {
          return candidate;
        }
      }
    }
    return '';
  }

  protected normalizeReplicateArtifacts(raw: unknown): Array<{
    kind: 'text' | 'image' | 'video';
    value: string;
    title?: string;
  }> {
    console.log('[DEBUG] normalizeReplicateArtifacts - input type:', typeof raw);
    if (typeof raw === 'string') {
      console.log('[DEBUG] normalizeReplicateArtifacts - string input:', raw.slice(0, 150));
    } else if (raw && typeof raw === 'object') {
      console.log('[DEBUG] normalizeReplicateArtifacts - object input keys:', Object.keys(raw as Record<string, unknown>));
    }

    const artifacts: Array<{ kind: 'text' | 'image' | 'video'; value: string; title?: string }> = [];
    const seenUrls = new Set<string>();
    const seenObjects = new WeakSet<Record<string, unknown>>();
    const urlKeys = ['output', 'url', 'uri', 'image', 'image_url', 'video', 'video_url', 'audio', 'href'];
    const textKeys = ['text', 'content', 'value', 'result', 'message'];

    const parseJsonIfPossible = (value: string): unknown | null => {
      const trimmed = value.trim();
      if (!trimmed || (!trimmed.startsWith('{') && !trimmed.startsWith('['))) {
        return null;
      }
      try {
        return JSON.parse(trimmed);
      } catch {
        return null;
      }
    };

    const addArtifact = (kind: 'text' | 'image' | 'video', value: string, title?: string) => {
      const trimmed = value.trim();
      if (!trimmed) {
        return;
      }
      if (kind !== 'text') {
        if (seenUrls.has(trimmed)) {
          return;
        }
        seenUrls.add(trimmed);
      }
      console.log('[DEBUG] normalizeReplicateArtifacts - adding artifact:', { kind, value: trimmed.slice(0, 100), title });
      artifacts.push({ kind, value: trimmed, title });
    };

    const visit = (value: unknown, titleHint?: string): void => {
      if (value === null || value === undefined) {
        return;
      }
      if (typeof value === 'string') {
        considerString(value, titleHint);
        return;
      }
      if (Array.isArray(value)) {
        value.forEach((item) => visit(item, titleHint));
        return;
      }
      if (typeof value === 'object') {
        const record = value as Record<string, unknown>;
        if (seenObjects.has(record)) {
          return;
        }
        seenObjects.add(record);
        const derivedTitle =
          titleHint || this.pickString(record, ['title', 'label', 'name', 'id']) || undefined;

        for (const key of urlKeys) {
          if (key in record) {
            visit(record[key], derivedTitle);
          }
        }

        for (const key of textKeys) {
          if (typeof record[key] === 'string') {
            considerString(record[key] as string, derivedTitle);
          }
        }

        for (const [key, entry] of Object.entries(record)) {
          if (urlKeys.includes(key) || textKeys.includes(key)) {
            continue;
          }
          visit(entry, derivedTitle);
        }
      }
    };

    const considerString = (value: string, title?: string) => {
      const trimmed = value.trim();
      if (!trimmed) {
        return;
      }
      console.log('[DEBUG] normalizeReplicateArtifacts - considerString:', trimmed.slice(0, 100));
      
      const parsed = parseJsonIfPossible(trimmed);
      if (parsed !== null) {
        console.log('[DEBUG] normalizeReplicateArtifacts - parsed JSON, visiting recursively');
        visit(parsed, title);
        return;
      }
      if (this.isLikelyUrl(trimmed)) {
        const kind = this.detectAssetKindFromUrl(trimmed);
        console.log('[DEBUG] normalizeReplicateArtifacts - detected URL kind:', kind, 'for URL:', trimmed.slice(0, 100));
        addArtifact(kind, trimmed, title);
        return;
      }
      console.log('[DEBUG] normalizeReplicateArtifacts - adding as text artifact');
      addArtifact('text', trimmed, title);
    };

    visit(raw);
    console.log('[DEBUG] normalizeReplicateArtifacts - total artifacts:', artifacts.length);
    return artifacts;
  }

  private deriveReplicateAssetPosition(sourceNode: StoredNode, index: number): { x: number; y: number } {
    const bbox = sourceNode.ui?.bbox;
    const baseX = bbox ? bbox.x2 : 0;
    const baseY = bbox ? bbox.y1 : 0;
    const spacingY = 220;
    return {
      x: Math.round(baseX + 200),
      y: Math.round(baseY + index * spacingY),
    };
  }

  /**
   * Convert localhost URLs to data URIs for external APIs
   * External APIs (Gemini, Replicate, etc.) cannot access localhost, so we need to convert local files to base64
   */
  private async convertUrlToDataUriIfNeeded(url: string): Promise<string> {
    try {
      // Check if this is a localhost URL
      if (!url.includes('localhost') && !url.includes('127.0.0.1')) {
        return url; // Already public URL or data URI
      }

      // Parse URL to extract file path
      const urlObj = new URL(url);
      const pathname = urlObj.pathname;
      
      // Extract relative path after /uploads/
      const uploadsMatch = pathname.match(/\/uploads\/(.+)/);
      if (!uploadsMatch) {
        console.warn(`[convertUrlToDataUriIfNeeded] Cannot parse uploads path from: ${url}`);
        return url;
      }

      const relativePath = uploadsMatch[1];
      const PROJECTS_ROOT = path.resolve(process.cwd(), 'projects');
      const absolutePath = path.join(PROJECTS_ROOT, relativePath);

      console.log(`[convertUrlToDataUriIfNeeded] Converting localhost URL to data URI: ${url}`);
      console.log(`[convertUrlToDataUriIfNeeded] Absolute path: ${absolutePath}`);

      const dataUri = await localFileToDataUri(absolutePath);
      console.log(`[convertUrlToDataUriIfNeeded] Converted to data URI (${dataUri.length} chars)`);
      
      return dataUri;
    } catch (error) {
      console.error(`[convertUrlToDataUriIfNeeded] Failed to convert URL:`, error);
      return url; // Fallback to original URL
    }
  }

  private buildRunMetadataSnapshot(
    node: StoredNode,
    result?: Partial<ExecutionStepResult>,
  ): Record<string, unknown> | null {
    const metaRecord = this.normalizeMetaRecord(node.meta);
    if (metaRecord.replicate && typeof metaRecord.replicate === 'object') {
      delete metaRecord.replicate;
    }
    if (metaRecord.metadata && typeof metaRecord.metadata === 'object' && !Array.isArray(metaRecord.metadata)) {
      const metadataRecord = { ...(metaRecord.metadata as Record<string, unknown>) };
      if (metadataRecord.replicate) {
        delete metadataRecord.replicate;
      }
      if (Object.keys(metadataRecord).length === 0) {
        delete metaRecord.metadata;
      } else {
        metaRecord.metadata = metadataRecord;
      }
    }

    const snapshot: Record<string, unknown> = {};
    const stringKeys = [
      'short_description',
      'output_type',
      'replicate_model',
      'replicate_version',
      'replicate_status',
      'replicate_prediction_id',
      'replicate_prediction_url',
      'replicate_prediction_api_url',
      'replicate_output',
    ];
    for (const key of stringKeys) {
      const value = metaRecord[key];
      if (typeof value === 'string' && value.trim()) {
        snapshot[key] = value.trim();
      }
    }

    if (typeof metaRecord.priority === 'string' && metaRecord.priority.trim()) {
      snapshot.priority = metaRecord.priority.trim();
    }
    if (typeof metaRecord.tags === 'string' && metaRecord.tags.trim()) {
      snapshot.tags = metaRecord.tags.trim();
    }
    if (metaRecord.replicate_last_run_at && typeof metaRecord.replicate_last_run_at === 'string') {
      snapshot.replicate_last_run_at = metaRecord.replicate_last_run_at;
    }
    if (metaRecord.ui_position && typeof metaRecord.ui_position === 'object' && !Array.isArray(metaRecord.ui_position)) {
      const pos = metaRecord.ui_position as Record<string, unknown>;
      const x = Number(pos.x);
      const y = Number(pos.y);
      if (Number.isFinite(x) && Number.isFinite(y)) {
        snapshot.ui_position = { x: Math.round(x), y: Math.round(y) };
      }
    }

    const createdEntries = this.resolveCreatedNodeLogEntries(node.project_id, node, result ?? {});
    if (createdEntries.length > 0) {
      snapshot.created_nodes = createdEntries;
    }

    const predictionPayload = this.resolvePredictionPayload(node, result ?? {});
    if (predictionPayload !== undefined) {
      snapshot.replicate_prediction_payload = predictionPayload;
    }

    if (result?.predictionUrl) {
      snapshot.prediction_url = result.predictionUrl;
    }
    if (result?.predictionId) {
      snapshot.prediction_id = result.predictionId;
    }
    if (result?.provider) {
      snapshot.provider = result.provider;
    }

    return Object.keys(snapshot).length > 0 ? snapshot : null;
  }

  private isLikelyUrl(value: string): boolean {
    const trimmed = value.trim();
    if (!trimmed) {
      return false;
    }
    if (this.isDataUri(trimmed)) {
      return true;
    }
    if (!/^https?:\/\//i.test(trimmed)) {
      return false;
    }
    try {
      new URL(trimmed);
      return true;
    } catch {
      return false;
    }
  }

  private detectAssetKindFromUrl(url: string): 'text' | 'image' | 'video' {
    const lower = url.toLowerCase();
    console.log('[DEBUG] detectAssetKindFromUrl - checking URL:', lower.slice(0, 150));
    
    if (this.isDataUri(lower)) {
      if (/^data:image\//.test(lower)) {
        console.log('[DEBUG] detectAssetKindFromUrl - detected image data URI');
        return 'image';
      }
      if (/^data:video\//.test(lower)) {
        console.log('[DEBUG] detectAssetKindFromUrl - detected video data URI');
        return 'video';
      }
    }
    if (/(\.png|\.jpg|\.jpeg|\.gif|\.webp|\.bmp|\.tiff)(\?.*)?$/.test(lower)) {
      console.log('[DEBUG] detectAssetKindFromUrl - detected image by extension');
      return 'image';
    }
    if (/(\.mp4|\.mov|\.webm|\.mkv|\.avi|\.mpe?g)(\?.*)?$/.test(lower)) {
      console.log('[DEBUG] detectAssetKindFromUrl - detected video by extension');
      return 'video';
    }
    if (/\bimage\b/.test(lower)) {
      console.log('[DEBUG] detectAssetKindFromUrl - detected image by keyword');
      return 'image';
    }
    if (/\bvideo\b/.test(lower)) {
      console.log('[DEBUG] detectAssetKindFromUrl - detected video by keyword');
      return 'video';
    }
    console.log('[DEBUG] detectAssetKindFromUrl - defaulting to text');
    return 'text';
  }

  private isDataUri(value: string): boolean {
    return /^data:(image|video)\/[a-z0-9.+-]+;base64,/i.test(value.trim());
  }

  private describeArtifactPlural(type: string, count: number): string {
    const dictionary: Record<string, [string, string, string]> = {
      image: ['изображение', 'изображения', 'изображений'],
      video: ['видео', 'видео', 'видео'],
      text: ['текст', 'текста', 'текстов'],
    };
    const forms = dictionary[type] ?? ['узел', 'узла', 'узлов'];
    return this.selectRussianPlural(count, forms);
  }

  private selectRussianPlural(count: number, forms: [string, string, string]): string {
    const n = Math.abs(count) % 100;
    const n1 = n % 10;
    if (n > 10 && n < 20) {
      return forms[2];
    }
    if (n1 > 1 && n1 < 5) {
      return forms[1];
    }
    if (n1 === 1) {
      return forms[0];
    }
    return forms[2];
  }

  private pickString(record: Record<string, unknown>, keys: string[]): string | null {
    for (const key of keys) {
      const value = record[key];
      if (typeof value === 'string' && value.trim()) {
        return value.trim();
      }
    }
    return null;
  }
}
